extends CanvasLayer
class_name SubtitlesLayerDialogue
"""
SubtitlesLayerDialogue
---
A subtitles layer for the character dialogue and any non-spatial subtitles that are crucial for the player to read


"""


class Dialogue:
	var stream_node : Node
	var sub_data : SubtitleData
	var theme_override : Theme
	
	func _init(sn : Node, sd : SubtitleData, to : Theme = null) -> void:
		stream_node = sn
		sub_data = sd
		theme_override = to

var side_padding := 20
var bottom_padding := 5
var max_stack_size := 3

var _dialogue_queue := []
onready var _dialogue_stack := VBoxContainer.new()

func _ready() -> void:
	add_child(_dialogue_stack)
	_dialogue_stack.set_anchors_and_margins_preset(Control.PRESET_WIDE) # fill screen
	_dialogue_stack.alignment = BoxContainer.ALIGN_END
	_dialogue_stack.margin_left = side_padding
	_dialogue_stack.margin_right = -side_padding
	_dialogue_stack.margin_bottom = -bottom_padding

func add_subtitle(stream_node : Node, sub_data : SubtitleData, theme_override : Theme = null) -> void:
	_dialogue_queue.append(Dialogue.new(stream_node, sub_data, theme_override))
	_refresh_stack()

func _refresh_stack() -> void:
	if not _dialogue_queue.empty() and _dialogue_stack.get_child_count() < max_stack_size:
		# add subtitle to stack
		var dialogue := _dialogue_queue.pop_front() as Dialogue
		var sub := _create_sub(dialogue.sub_data)
		_dialogue_stack.add_child(sub)
		_create_subtitle_timer(sub, dialogue.stream_node, dialogue.sub_data)
		sub.connect("tree_exited", self, "_refresh_stack", [], CONNECT_DEFERRED) # one frame after it exits the tree, refresh the stack again
		if dialogue.theme_override != null:
			sub.theme = dialogue.theme_override

func _create_sub(sub_data : SubtitleData) -> PanelContainer:
	var panel := PanelContainer.new()
	var key := sub_data.subtitle_key
	if key.find(":") != -1:
		# treat as character dialogue, 3D positional
		var vbox := VBoxContainer.new()
		var lbl_name := Label.new()
		var lbl_text := Label.new()
		var parts := key.split(":", false, 1)
		lbl_name.text = parts[0] as String
		lbl_text.text = parts[1] as String
		lbl_text.autowrap = true
		vbox.add_child(lbl_name)
		vbox.add_child(lbl_text)
		panel.add_child(vbox)
	else:
		# treat as general subtitle
		var label := Label.new()
		label.text = sub_data.subtitle_key
		panel.add_child(label)
	_create_panel_name(panel, sub_data)
	return panel

func _create_subtitle_timer(panel : PanelContainer, audio : Node, sub_data : SubtitleData) -> void:
	var timer := Timer.new()
	panel.add_child(timer)
	timer.wait_time = max(audio.stream.get_length() + sub_data.subtitles_padding, 0.001) # make sure the wait time doesn't go negative
	timer.connect("timeout", panel, "queue_free")
	timer.start()

var _subtitle_id :int= 0 # this is tucked here because it is only used here
func _create_panel_name(panel : PanelContainer, sub_data : SubtitleData) -> void:
	# sets the subtitle's name to be something like "Sub3D_key_023"
	# the ID is not specific to any one key since there could be thousands of keys. It just heavily decreases the potential for any two suibtitles having the same name, which results in a garbage-looking name generated by Godot
	panel.name = "SubCharacter_" + sub_data.subtitle_key + "_" + str(_subtitle_id).pad_zeros(3)
	_subtitle_id += 1
	_subtitle_id %= 999
